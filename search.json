[{"title":"java基础","path":"/2025/03/29/java基础/","content":"Java基础java八种基本数据类型8位1字节 数值型：整数类型：int 32位（2的31次方-1） short 16位（2的15次方-1） long 64位（2的63次方-1） byte 8位（2的7次方-1） ​ 浮点类型：float 32位（2的31次方-1） double 64位（2的63次方-1） 字符型： char（0~2的7次方-1） 16位 布尔型 ：boolean 8位 数据类型转换方式你知道哪些？ 自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为long、将float转换为double等。 强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将long转换为int、将double转换为int等。语法为：目标类型 变量名 (目标类型) 源类型。 字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double，可以使用Double.parseDouble()方法等。 数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。 类型互转会出现什么问题吗 数据丢失：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如，将一个long类型的值转换为int类型时，如果long值超出了int类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。 数据溢出：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如，将一个int类型的值转换为long类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。 精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(float)转换为双精度浮点数(double)时，精度可能会损失。 类型不匹配导致的错误：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误。 抽象类和接口有什么区别抽象类是类，有类的共性，可以定义公共的属性和方法，类的继承只能是单继承。 接口更像是一种规范（类的行为规范），描述了一个方法的集合，接口是多继承。 Java为什么要有包装类包装类是Java中一种特殊的类，主要作用是把基础数据类型转化成对象。 包装类的作用 提供方法和属性:包装类提供了许多有用的属性和方法，比如Integer类有parseInt（）方法 将基本数据类型转换为对象：java是面向对象的编程语言，包装类使基本数据类型以对象的形式操作 方便泛型编程：在泛型编程中，只能使用对象类型。 包装类型的缓存机制了解么？Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。 Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False 自动装箱与拆箱了解吗？原理是什么？什么是自动拆装箱？ 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 举例： Integer i = 10; //装箱int n = i; //拆箱 原理 自动装箱：将基本数据类型赋值给其对应的包装类时，编译时会生成其对应valueof（）方法创建一个包装类的实例，并将基本类型的值传递给他 Integer i = 100;//编译后Integer i = Integer.valueOf(100); 自动拆箱：将包装类赋值给基本数据类型时，编译时会调用xxxValue（）方法，xxx指对应的类型 Integer i = 100;int n = i;//编译后int n = i.intValue(); 自动装拆箱存在的问题 频繁的对象创建和销毁：自动装箱会创建对象，若在循环中用到了自动装拆箱，涉及频繁的对象创建和销毁，导致性能下降。 空指针异常：若是包装对象为null，自动拆箱时就会报空指针异常 如何解决浮点数运算的精度丢失问题？BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。 和.equal（）的区别 **：**如果比较基本数据类型，就是比较值，如果比较对象，就是比较对象地址 **equals()：**默认比较对象的地址，一般重写用于比较对象的内容 重写.equal()为什么要重写.hashcode()?hashmap和hashset通过hashcode()计算对象的哈希值，确定其在哈希表中的存储位置。如果hashcode（）相等，就会通过equal（）方法进行比较。如果重写equal（）方法不重写hashcode（）方法，就会导致hashmap无法正常工作，如get方法无法返回已存在的键 String类String 为什么是不可变的? 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 StringBuffer和StringBuilder区别是什么？ String 是 Java 中基础且重要的类，被声明为 final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。 StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。通过同步锁sychronized实现 StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。 字符串常量池的作用了解吗字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。 Strings 与new String有什么区别？ Strings是字符串池中的字符串，它们是在编译时就确定的，如果字符串池中已经存在相同的字符串，则直接返回池中的引用。 new String创建的字符串对象是在堆内存中的，每次调用new String都会创建一个新的字符串对象，即使字符串内容相同。 String s1 new String(“abc”)这句话创建了几个字符串对象？先说答案：会创建 1 或 2 个字符串对象。 字符串常量池中不存在 “abc”：会创建 2 个 字符串对象。一个在字符串常量池中，由 ldc 指令触发创建。一个在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。 字符串常量池中已存在 “abc”：会创建 1 个 字符串对象。该对象在堆中，由 new String() 创建，并使用常量池中的 “abc” 进行初始化。 内部类四种类型：成员内部类、静态内部类、局部内部类和匿名内部类。 1.成员内部类： 成员内部类是定义在另一个类内部的类，它与外部类的实例关联密切。 成员内部类可以访问外部类的所有成员，包括私有成员，并且可以使用外部类的引用（即this关键字）来访问外部类的实例。 成员内部类的创建依赖于外部类的实例。 public class Outer private int x; public class Inner public void display() System.out.println(Value of x: + x); 2.静态内部类： 静态内部类是被声明为静态的内部类，它不依赖于外部类的实例。 静态内部类不能直接访问外部类的非静态成员，但可以访问外部类的静态成员。 静态内部类可以通过外部类名直接访问，不需要外部类的实例。 public class Outer private static int x; public static class StaticInner public void display() System.out.println(Value of x: + x); 3.局部内部类： 局部内部类是定义在方法或作用域内部的类，它只能在定义它的方法或作用域内部访问。 局部内部类对外部类和外部方法的访问权限与匿名内部类相同，可以访问外部类的成员和方法的局部变量，但要求局部变量必须是final的或者事实上是final的。 public class Outer public void display() final int x = 10; class LocalInner public void displayX() System.out.println(Value of x: + x); LocalInner localInner = new LocalInner(); localInner.displayX(); 4.匿名内部类： 匿名内部类是一种没有命名的局部内部类，它通常用于创建实现某个接口或继承某个类的对象。 匿名内部类没有构造器，它是隐式地继承了外部类或实现了接口，并且可以在创建对象时进行方法重写。 匿名内部类可以访问外部类的成员和方法的局部变量，但要求局部变量必须是final的或者事实上是final的。 public class Outer public void display() final int x = 10; Runnable r = new Runnable() @Override public void run() System.out.println(Value of x: + x); ; new Thread(r).start(); java面向对象面向对象和面向过程的区别 面向过程编程（POP）：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象编程（OOP）：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。 相比较于 POP，OOP 开发的程序一般具有下面这些优点： 易维护：由于良好的结构和封装性，OOP 程序通常更容易维护。 易复用：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。 易扩展：模块化设计使得系统扩展变得更加容易和灵活。 对象的相等和引用相等的区别 对象的相等一般比较的是内存中存放的内容是否相等。 引用相等一般比较的是他们指向的内存地址是否相等。 java传参的方式在 Java 中，传参使用的是值传递（pass-by-value）。这意味着方法调用时，传递的是参数的副本，而不是参数本身。对于基本数据类型（如 int、double 等），这个副本就是值本身；对于引用类型（如对象、数组等），这个副本是引用的副本，即对象的地址。 面向对象三大特性 封装：将属性和方法绑定在一个类上，对外隐藏类的实现，仅提供接口访问数据 ​ 封装防止外部直接修改内部数据，保证安全性；仅对外提供接口，不必关心内部实现细节，保证简化使用 继承：子类可以服用父类的属性和方法，也可以根据自身特性重写或者扩展的能力 ​ 实现了代码复用，建立层次关系 多态：多态是指允许不同类的对象对同一消息作出响应。即同一个接口，使用不同的实例而执行不同操作。 ​ 运行时多态：父类引用指向子类对象，调用方法时实际执行子类重写的方法。List list new ArrayList(); ​ 多态性可以分为编译时多态（重载）和运行时多态（重写）。它使得程序具有良好的灵活性和扩展性。 深拷贝和浅拷贝 浅拷贝​\t浅拷贝是指复制对象时，仅复制对象本身，而不复制对象所引用的其他对象。复制对象引用时，不产生副本，引用原来的对象。 深拷贝​\t深拷贝是指复制对象时，不仅复制对象本身，还复制对象所引用的其他对象。复制对象引用时，产生副本，不引用原来的对象。 实现深拷贝的方式 实现 Cloneable 接口并重写 clone() 方法：要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。 使用序列化和反序列化：通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。 手动递归复制：针对特定对象结构，手动递归复制对象及其引用类型字段。适用于对象结构复杂度不高的情况。 泛型泛型是Java中的一种编程机制，它允许在编译时指定类型参数，以在代码中实现类型安全和代码重用 作用 适用于多种数据类型执行相同代码 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型） 对象创建java对象的方式 new关键字创建对象实例 使用Class类的newInstance()方法：通过反射机制，可以使用Class类的newInstance()方法创建对象。 使用Constructor类的newInstance()方法：同样是通过反射机制，可以使用Constructor类的newInstance() 使用反序列化：通过将对象序列化到文件或流中，然后再进行反序列化来创建对象。 使用clone()方法：如果类实现了Cloneable接口，可以使用clone()方法复制对象。 反射反射是指在运行时动态地获取类的信息以及在运行时动态调用类的方法和操作类的属性的能力 反射通过类加载器加载类文件创建的class对象，来获取类的详细信息。 反射具有以下特性： 运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。 动态对象创建：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。 动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。 访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。 使用场景 动态加载数据库驱动： 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序 配置文件的加载：Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载 异常 Exception：指程序本身可以处理的异常，可以用catch捕捉， 分为checked Exception（受检查异常，必须处理）和Unchecked Exception（不受检查异常，可以不处理） Error：程序无法处理的错误 如OOM（虚拟机内存不够错误）不建议用catch捕获，一旦出现终止程序 Checked Exception 和 Unchecked Exception 有什么区别？checked Exception 即受检查异常：java代码编译时如果这些受检查异常没有被捕获，就无法通过编译 ​ 如IO 相关的异常、ClassNotFoundException、SQLException…。 Unchecked Exception 即不受检查异常：java代码编译时就算这些受检查异常没有被捕获，也可以通过编译 ​ 如空指针访问（NullPointerException）数组越界（ArrayIndexOutOfBoundsException） 有哪些常见的运行时异常?运行时异常（Runtime Exception）是在程序运行过程中可能会抛出的异常，它们通常是由程序错误或逻辑错误导致的，而不是由于外部环境或输入数据引起的。以下是一些常见的运行时异常： NullPointerException（空指针异常）： ￮ 当试图访问一个空对象的属性或调用空对象的方法时抛出。 IndexOutOfBoundsException（下标越界异常）： ￮ 当使用了非法的索引访问数组、字符串或集合等容器时抛出。 ArithmeticException（算术异常）： ￮ 当进行数学运算出现异常情况时抛出，比如除数为零。 IllegalArgumentException（非法参数异常）： ￮ 当方法接收到一个不合法的参数时抛出，比如负数作为数组长度、空字符串作为方法的参数等。 ClassCastException（类转换异常）： ￮ 当试图将一个对象转换为不兼容的类类型时抛出。 NumberFormatException（数字格式异常）： ￮ 当字符串转换为数字时发生格式错误时抛出，比如 Integer.parseInt(“abc”)。 ConcurrentModificationException（并发修改异常）： ￮ 当多个线程同时修改集合对象时，可能会导致集合的结构发生变化，从而抛出此异常。 StackOverflowError（栈溢出异常）： ￮ 当方法的调用栈过深，超出 JVM 栈的深度限制时抛出。 OutOfMemoryError（内存溢出异常）： ￮ 当程序尝试申请的内存超出了 JVM 的堆内存限制时抛出。 NoClassDefFoundError（类未找到异常）： ￮ 当 JVM 尝试加载某个类但找不到其定义时抛出。 这些异常通常表示了程序的错误或者逻辑错误，需要通过合适的异常处理机制来处理，以保证程序的健壮性和稳定性。 IOBIO、NIO、AIO区别是什么？ BIO（blocking IO）：就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。优点是代码比较简单、直观；缺点是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。 NIO（non-blocking IO） ：Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。 AIO（Asynchronous IO） ：是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 NIO的实现原理NIO同步的核心就是selector（选择器），代替了线程本身轮询IO事件。非阻塞的核心是canncel（通道）和缓冲区（buffer），当IO事件准备好后，写到缓冲区。数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 可以注册多个cannel到一个selector上（可以带上感兴趣的事件），一个selector监听多个cannel，当注册的事件准备就绪，应用程序就会使用一个或者多个线程处理就绪的事件。 IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 - 用户空间）还是阻塞的。","tags":["java"],"categories":["java学习"]},{"title":"我的第一篇博客","path":"/2025/03/28/我的第一篇博客/","content":"hello你好","tags":["人生感悟"],"categories":["个人生活感想"]},{"title":"Hello World","path":"/2025/03/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"}]